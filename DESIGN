Design document


A 'gui' is one of the following:

     (message string-value)
   | (button string-value boolean-value callback)
   | (slider number-value number-value number-value ncallback)
   | (drop-down string-value strings-value scallback)
   | (text-field string-value scallback)
   | (scene scene-value)
   | (row guis)
   | (col guis))

where:

    callback: world -> world
    ncallback: world number -> world
    scallback: world string -> world

    boolean-value: boolean
                 | (world -> boolean)

    number-value: number
                | (world -> number)

    string-value: string
                | (world -> string)

    strings-value: (listof string)
                | (world -> (listof string))

    scene-value: scene
                | (world -> scene)

    guis: (listof gui)


The boolean-value, number-value, string-value, strings-value, and
scene-value are special because they can either be of the respective
primitive type or of a function type from world going to that type.


A gui is a declarative definition of what's on screen; it specifies
the view and controller of the graphical program, and the relationship
to the world model.  The dynamic '*-value' types map the binding from
the world model to the its presentation on the gui.  The callbacks on
each control map user operations to updates on the world model.



----------------------------------------------------------------------

To hook into the world system, we provide two functions:

    big-bang: world gui -> #t

    on-tick: number (world -> world) -> #t


Minor differences from the original world functions:

    * The parameter describing the tick delay is moved from big-bang
      to the first argument on on-tick.

    * width and height are no longer passed into big-bang.  The gui will
      resize itself automatically to the minimum size necessary to fit
      everything.

----------------------------------------------------------------------

GUI Example

A gui that contains a counter and a button that increments that
counter will be defined as:


;; A world is a number whose value is initially zero.
(define INITIAL-WORLD 0)

(define (on-button-pressed a-world)
  (add1 a-world))

(define (world-counter a-world)
  (number->string a-world))

(define counter-gui
  (col (message world-counter)
       (button "Press me!" on-button-pressed)))

(big-bang INITIAL-WORLD counter-gui)


on-tick is not used since there is no animation in this example.


(SK) Note on the number->string: maybe we should coerce the base types
to string to reduce the hassle to get working programs.

----------------------------------------------------------------------

Aside

We want to have update functions that are automatically defined when a define-struct is used.  For example:

    (define-struct 3d (x y z))


should also bind identifiers 'update-3d-x, 'update-3d-y, and
'update-3d-z to functions that functionally update the attributes of a
3d structure.  We can reuse struct-copy.


----------------------------------------------------------------------


GUI Example

A ball moves across the screen, its radius controlled by a slider.

(define WIDTH 300)
(define HEIGHT 300)

(define MIN-RADIUS 20)
(define MAX-RADIUS 100)

;; A world is the ball's radius and its X coordinate
(define-struct world (radius x))


;; INITIAL-WORLD: world
;; The ball is of MIN-RADIUS radius, and all the way to the left.
(define INITIAL-WORLD (make-world MIN-RADIUS 0))

;; change-radius: world number -> world
;; Changes the radius to the new radius.
(define (change-radius a-world new-radius)
  (update-world-radius a-world new-radius))

;; move-ball: world -> world
;; Moves the ball to the right, circling around if it goes beyond.
(define (move-ball a-world)
  (update-world-x a-world (modulo (add1 (world-x a-world)) WIDTH)))

;; draw-world: world -> scene
;; Consumes the world, and draws the world.
(define (draw-world a-world)
  (place-image (circle radius "solid" "red")
               (world-x a-world)
               (/ HEIGHT 2)
               (empty-scene WIDTH HEIGHT)))

;; a-gui: gui with a scene on top, and a slider below it.
(define a-gui
  (col (scene draw-world)
       (slider world-radius MIN-RADIUS MAX-RADIUS change-radius)))

;; Let's fire up the world.
(big-bang INITIAL-WORLD a-gui)
(on-tick 1/30 move-ball)

----------------------------------------------------------------------


Consequences of the design

* A lot of the values that we use to construct the gui will need to be
functions.  For example, a user may intend to create a slider whose
initial position is at zero, and mistakenly try to do this:

    (slider 0 0 200 a-callback)

But this represents a slider that is constantly fixed to zero.  What
the user should say is:

    (slider world-slider-pos 0 200 a-callback)

where world-slider-pos, applied to the initial world, produces zero.
This may be an awkward part of this design, but I don't see a way
around it yet.



* We can support multiple scenes in a single gui, since each scene
element of a gui can take in a function from (world -> scene).  That
is, we can do:

  (row (scene world->scene-1)
       (scene world->scene-2))

to provide different perspective renderings of the world.
